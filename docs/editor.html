<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Auto musicL Maker</title>
    <style>
      :root { color-scheme: light dark; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; line-height: 1.4; }
      h1 { font-size: 1.4rem; margin: 0 0 16px; }
      h2 { font-size: 1.1rem; margin: 24px 0 8px; }
      .row { display: grid; grid-template-columns: 200px 1fr auto; gap: 12px; align-items: center; margin: 8px 0; }
      .row textarea { grid-column: 2 / span 2; }
      .toolbar { align-items: center; }
      input, textarea, button { box-sizing: border-box; }
      input[type="text"], input[type="url"], textarea { width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #9993; }
      textarea { min-height: 80px; }
      .toolbar { display: flex; gap: 8px; flex-wrap: wrap; margin: 12px 0; }
      button { padding: 8px 12px; border-radius: 6px; border: 1px solid #9993; background: #eee; cursor: pointer; }
      button.primary { background: #1e88e5; color: #fff; border-color: #1e88e5; }
      button.danger { background: #d32f2f; color: #fff; border-color: #d32f2f; }
      table { width: 100%; border-collapse: collapse; margin-top: 8px; }
      th, td { border-bottom: 1px solid #9993; padding: 8px; text-align: left; }
      tbody tr:hover { background: #9991; }
      .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
      .card { border: 1px solid #9993; border-radius: 10px; padding: 8px 16px 16px; margin-bottom: 16px; }
      .card > h2 { margin: 0 0 8px; }
      .muted { opacity: 0.75; }
      .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
      @media (max-width: 880px) { .grid2 { grid-template-columns: 1fr; } .row { grid-template-columns: 1fr; } }
      .footer { margin-top: 16px; font-size: 0.9rem; }
      .success { color: #2e7d32; }
      .warn { color: #ef6c00; }


      /* Dark mode readability tweaks */
      @media (prefers-color-scheme: dark) {
        body { background: #0f1115; color: #e5e7eb; }
        .card { background: #111827; border-color: #374151; }
        input[type="text"], input[type="url"], textarea {
          background: #1f2937; color: #e5e7eb; border: 1px solid #374151;
        }
        input::placeholder, textarea::placeholder { color: #9ca3af; }
        button { background: #374151; color: #e5e7eb; border-color: #4b5563; }
        button.primary { background: #2563eb; border-color: #2563eb; color: #fff; }
        button.danger { background: #dc2626; border-color: #dc2626; color: #fff; }
        th, td { border-bottom-color: #374151; }
        tbody tr:hover { background: #1f2937; }
      }

      /* Focus visibility */
      input[type="text"], input[type="url"], textarea, button { transition: border-color .15s, box-shadow .15s; }
      input:focus, textarea:focus {
        outline: 2px solid #60a5fa; outline-offset: 1px; border-color: #60a5fa;
      }
      button:focus { outline: 2px solid #93c5fd; outline-offset: 2px; }
      button:disabled { opacity: 0.6; cursor: not-allowed; }
    </style>
  </head>
  <body>
    <h1>Auto musicL Maker</h1>

    <div class="toolbar">
      <button id="btnHowTo">How to</button>
      <input id="feedUrl" type="url" placeholder="https://example.com/feed.xml" style="flex:1;min-width:260px;" />
      <button id="btnLoad">Load</button>
      <button id="btnGenerate" class="primary">Generate XML</button>
      <button id="btnDownload">Download XML</button>
      <span id="status" class="muted"></span>
    </div>

    <dialog id="howToModal" style="max-width:680px;">
      <h2 style="margin-top:0;">How to</h2>
      <ol>
        <li>Paste an XML feed into the box</li>
        <li>Click Load or press Enter</li>
        <li>Enter your info for the playlist you're making</li>
        <li>If this is a new feed click the "Generate GUID" button.</li>
        <li>Click Generate XML</li>
        <li>The new feed will show up in the Output box</li>
        <li>Click Download XML to save the new feed</li>
      </ol>
      <form method="dialog" style="margin-top:12px;">
        <button>Close</button>
      </form>
    </dialog>

    <div class="card">
      <h2>Channel</h2>
      <div class="row"><label for="author">Author</label><input id="author" type="text" placeholder="ChadF" /></div>
      <div class="row"><label for="title">Title</label><input id="title" type="text" /></div>
      <div class="row"><label for="description">Description</label><textarea id="description"></textarea></div>
      
      <div class="row"><label for="pubDate">Playlist Date (pubDate)</label>
        <div style="display:flex; gap:8px; align-items:center;">
          <input id="pubDate" type="text" class="mono" placeholder="Fri, 08 Aug 2025 03:06:58 GMT" />
          <button id="btnNow" type="button">Now</button>
        </div>
      </div>
      <div class="card" style="margin-top:12px;">
        <h2>Image</h2>
        <div class="row"><label for="imageUrl">image.url</label><input id="imageUrl" type="url" /></div>
      </div>
      <div class="card">
        <h2>GUID <span class="muted" style="font-weight: normal;">If this is a new feed, click "Generate GUID".</span></h2>
        <div class="row">
          <label for="podGuid">podcast:guid</label>
          <div style="display:flex; gap:8px; align-items:center;">
            <input id="podGuid" type="text" class="mono" placeholder="auto-generate v4 UUID" />
            <button id="btnGenGuid" type="button">Generate GUID</button>
          </div>
        </div>
      </div>
    </div>

    

    <div class="card">
      <h2>Output</h2>
      <pre id="output" class="mono" style="white-space: pre; overflow: visible;"></pre>
    </div>

    

    <script>
      const QS = (sel) => document.querySelector(sel);
      const el = {
        author: QS('#author'),
        title: QS('#title'),
        description: QS('#description'),
        
        pubDate: QS('#pubDate'),
        // removed: language, lastBuildDate inputs
        imageUrl: QS('#imageUrl'),
        podGuid: QS('#podGuid'),
        output: QS('#output'),
        status: QS('#status'),
        btnHowTo: QS('#btnHowTo'),
        howToModal: QS('#howToModal'),
        btnLoad: QS('#btnLoad'),
        feedUrl: QS('#feedUrl'),
        btnGenerate: QS('#btnGenerate'),
        btnDownload: QS('#btnDownload'),
        btnGenGuid: QS('#btnGenGuid'),
        btnNow: QS('#btnNow'),
      };

      function setStatus(msg, tone = 'muted') {
        el.status.className = tone;
        el.status.textContent = msg;
      }

      function rfc822Now() {
        return new Date().toUTCString();
      }

      function clearTable() {}

      function addRow() {}

      function readRows() { return []; }

      let currentDoc = null; // stores the last loaded/pasted XML Document
      let feedLinkOriginal = '';

      function populateFromDoc(doc) {
        const channel = doc.querySelector('channel');
        if (!channel) throw new Error('Missing <channel>');

        currentDoc = doc;

        const text = (sel) => channel.querySelector(sel)?.textContent?.trim() || '';
        const textByTag = (tagName) => {
          const node = channel.getElementsByTagName(tagName)[0];
          return node?.textContent?.trim() || '';
        };

        el.author.value = text('author');
        el.title.value = text('title');
        el.description.value = text('description');
        feedLinkOriginal = text('link');
        el.pubDate.value = text('pubDate');
        el.imageUrl.value = channel.querySelector('image > url')?.textContent?.trim() || '';
        // Read namespaced tag using tagName to avoid CSS selector colon issues
        el.podGuid.value = textByTag('podcast:guid');

        // Items UI removed; skip remoteItem table population
        setStatus('Loaded');
      }

      async function fetchXmlFrom(urlStr) {
        const u = new URL(window.location.origin);
        // Prefer production serverless proxy when deployed, fallback to local dev route
        const proxyPath = '/api/proxy';
        const res = await fetch(`${proxyPath}?url=${encodeURIComponent(urlStr)}`, { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return await res.text();
      }

      function parseXml(xmlText) {
        const parser = new DOMParser();

        function sanitize(text) {
          if (!text) return '';
          let t = text.replace(/^\uFEFF/, '').trim(); // strip BOM
          // If there is preface text before the XML (e.g., human-readable header),
          // cut everything before the XML declaration or root tag.
          const anchors = ['<?xml', '<rss', '<feed'];
          let idx = -1;
          for (const a of anchors) {
            const i = t.indexOf(a);
            if (i !== -1 && (idx === -1 || i < idx)) idx = i;
          }
          if (idx > 0) t = t.slice(idx);

          // Also trim any trailing text after the closing tag
          const endTags = ['</rss>', '</feed>'];
          let endIdx = -1;
          for (const e of endTags) {
            const j = t.lastIndexOf(e);
            if (j !== -1 && j + e.length > endIdx) endIdx = j + e.length;
          }
          if (endIdx !== -1) t = t.slice(0, endIdx);
          return t;
        }

        let cleaned = sanitize(xmlText);
        let doc = parser.parseFromString(cleaned, 'text/xml');
        let err = doc.querySelector('parsererror');

        if (err) {
          // As a fallback, try trimming to the first '<' we can find
          const firstLt = cleaned.indexOf('<');
          if (firstLt > 0) {
            cleaned = cleaned.slice(firstLt);
            doc = parser.parseFromString(cleaned, 'text/xml');
            err = doc.querySelector('parsererror');
          }
        }

        if (err) throw new Error('Invalid XML');
        return doc;
      }

      function buildXml() {
        // Create new document preserving podcast namespace
        const doc = document.implementation.createDocument('', '', null);

        const rss = doc.createElement('rss');
        rss.setAttribute('version', '2.0');
        rss.setAttribute('xmlns:podcast', 'https://github.com/Podcastindex-org/podcast-namespace/blob/main/docs/1.0.md');
        doc.appendChild(rss);

        const channel = doc.createElement('channel');
        rss.appendChild(channel);

        function appendText(tag, value) {
          if (!value) return;
          const node = doc.createElement(tag);
          node.textContent = value;
          channel.appendChild(node);
        }

        appendText('author', el.author.value.trim());
        appendText('title', el.title.value.trim());
        appendText('description', el.description.value.trim());
        appendText('link', feedLinkOriginal);
        // Optional: default language and updated dates
        appendText('language', 'en');
        appendText('pubDate', el.pubDate.value.trim() || rfc822Now());
        appendText('lastBuildDate', rfc822Now());

        const image = doc.createElement('image');
        function imgChild(tag, value) {
          if (!value) return;
          const n = doc.createElement(tag);
          n.textContent = value;
          image.appendChild(n);
        }
        imgChild('url', el.imageUrl.value.trim());
        if (image.childNodes.length > 0) channel.appendChild(image);

        appendText('podcast:medium', 'musicL');
        appendText('podcast:guid', el.podGuid.value.trim() || generateUUIDv4());

        // Prefer all podcast:remoteItem entries found in the source feed (tracks within episodes)
        try {
          const seenKey = new Set();
          if (currentDoc) {
            const remotes = Array.from(currentDoc.getElementsByTagName('podcast:remoteItem'));
            for (const r of remotes) {
              const fg = r.getAttribute('feedGuid')?.trim();
              const ig = r.getAttribute('itemGuid')?.trim();
              if (!fg || !ig) continue;
              const key = fg + '::' + ig;
              if (seenKey.has(key)) continue;
              seenKey.add(key);
              const remote = doc.createElement('podcast:remoteItem');
              remote.setAttribute('feedGuid', fg);
              remote.setAttribute('itemGuid', ig);
              channel.appendChild(remote);
            }
            // Fallback: if none found, include episode GUIDs as before
            if (remotes.length === 0) {
              const ch = currentDoc.querySelector('channel');
              const feedGuid = (currentDoc.getElementsByTagName('podcast:guid')[0]?.textContent || '').trim();
              if (ch && feedGuid) {
                const directItems = Array.from(ch.children).filter(n => n.tagName && n.tagName.toLowerCase() === 'item');
                const seen = new Set();
                for (const it of directItems) {
                  const guidNode = it.querySelector('guid');
                  const g = (guidNode?.textContent || '').trim();
                  if (!g || seen.has(g)) continue;
                  seen.add(g);
                  const remote = doc.createElement('podcast:remoteItem');
                  remote.setAttribute('feedGuid', feedGuid);
                  remote.setAttribute('itemGuid', g);
                  channel.appendChild(remote);
                }
              }
            }
          }
        } catch (_) { /* ignore */ }
        // No <item> wrapper is used in the generated playlist

        const xml = new XMLSerializer().serializeToString(doc);
        return formatXml(xml);
      }

      function formatXml(xml) {
        // Simple pretty printer for readability
        const PADDING = '  ';
        const reg = /(>)(<)(\/*)/g;
        let formatted = '';
        let pad = 0;
        xml = xml.replace(reg, '$1\n$2$3');
        xml.split('\n').forEach((node) => {
          if (node.match(/^\s*<\//)) pad -= 1;
          formatted += PADDING.repeat(pad) + node + '\n';
          if (node.match(/^\s*<[^!?][^>]*[^\/]>/) && !node.includes('</')) pad += 1;
        });
        return formatted.trim();
      }

      // GUID generator (RFC 4122 v4) using Web Crypto
      function generateUUIDv4() {
        const bytes = new Uint8Array(16);
        crypto.getRandomValues(bytes);
        // Per RFC 4122 v4: set version and variant bits
        bytes[6] = (bytes[6] & 0x0f) | 0x40;
        bytes[8] = (bytes[8] & 0x3f) | 0x80;
        const hex = [...bytes].map(b => b.toString(16).padStart(2, '0'));
        return (
          hex.slice(0, 4).join('') + '-' +
          hex.slice(4, 6).join('') + '-' +
          hex.slice(6, 8).join('') + '-' +
          hex.slice(8, 10).join('') + '-' +
          hex.slice(10, 16).join('')
        );
      }

      // Events
      async function loadFeed(urlInput) {
        try {
          setStatus('Loading…');
          const urlToLoad = (urlInput || el.feedUrl.value || '').trim();
          if (!urlToLoad) throw new Error('Enter a feed URL');
          const xml = await fetchXmlFrom(urlToLoad);
          const doc = parseXml(xml);
          populateFromDoc(doc);
          setStatus('Loaded', 'success');
        } catch (e) {
          setStatus('Load failed: ' + (e?.message || e), 'warn');
          throw e;
        }
      }

      el.btnLoad.addEventListener('click', () => { loadFeed().catch(() => {}); });

      el.btnHowTo.addEventListener('click', () => {
        el.howToModal.showModal();
      });

      // Hitting Enter in the feed URL field triggers Load
      el.feedUrl.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          loadFeed().catch(() => {});
        }
      });

      // File uploader removed

      // Paste XML UI removed

      el.btnGenerate.addEventListener('click', () => {
        try {
          const xml = buildXml();
          el.output.textContent = xml;
          setStatus('XML generated', 'success');
        } catch (e) {
          setStatus('Generate failed: ' + (e?.message || e), 'warn');
        }
      });

      el.btnDownload.addEventListener('click', () => {
        const text = (el.output.textContent || '').trim() || buildXml();
        const blob = new Blob([text + '\n'], { type: 'application/xml' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'doerfel-verse-music.xml';
        a.click();
        URL.revokeObjectURL(a.href);
      });

      // Items UI removed

      // Generate GUID on demand
      el.btnGenGuid.addEventListener('click', () => {
        el.podGuid.value = generateUUIDv4();
        setStatus('New GUID generated', 'success');
      });

      // Set pubDate to now
      el.btnNow.addEventListener('click', () => { el.pubDate.value = rfc822Now(); });

      // If no GUID present, show a suggestion immediately
      if (!el.podGuid.value) {
        el.podGuid.value = generateUUIDv4();
      }

      // Preload logic: support ?url=<feed>&autoload=1 to auto-load a feed
      (function initPreload() {
        const params = new URLSearchParams(window.location.search);
        const fromUrl = params.get('url');
        const autoload = params.get('autoload');
        // Do not preload by default. If a url param is present, just prefill the field.
        if (fromUrl) {
          el.feedUrl.value = fromUrl;
          // Only auto-load when explicitly requested
          if (autoload === '1' || autoload === 'true') {
            loadFeed().catch(() => {});
          }
        }
        // No fallback default URL; leave input empty unless provided
      })();
    </script>
  </body>
  </html>


